#include "environment.h"
#include <iostream>
#include <fstream>
#include <yaml-cpp/yaml.h>

POI::POI(int id, int classId, double x, double y, double observationRadius, int coupling, 
    int reward, int penalty)
    : id(id), classId(classId), x(x), y(y), observationRadius(observationRadius), coupling(coupling), 
    reward(reward), penalty(penalty) {}

void Environment::loadConfig(const std::string& filename) {
    YAML::Node config = YAML::LoadFile(filename); // Parse YAML from file

    const YAML::Node& dimensions = config["environment"]["dimensions"];
    xLength = dimensions["xLength"].as<double>();
    yLength = dimensions["yLength"].as<double>(); // Read the environment dimensions into the object

    int numberOfPOIs = config["environment"]["numberOfPOIs"].as<int>();
    int numberOfClassIDs = config["environment"]["numberOfClassIds"].as<int>();

    int poisPerClass = numberOfPOIs / numberOfClassIDs;
    int remainingPOIs = numberOfPOIs % numberOfClassIDs;

    int poi_num = 0; // Initialize poi_num outside the loop
    for (int classID = 0; classID < numberOfClassIDs; ++classID) {
        int poisToAdd = poisPerClass + (classID < remainingPOIs ? 1 : 0);
        for (int i = 0; i < poisToAdd; ++i) {
            // Random POI position
            double poi_x = rand() % xLength;
            double poi_y = rand() % yLength;

            // Put into list
            pois.emplace_back(poi_num++, classID, poi_x, poi_y, 
            config["environment"]["observationRadius"].as<double>(),
            config["environment"]["coupling"].as<int>(),
            config["environment"]["reward"].as<int>(),
            config["environment"]["penalty"].as<int>()); // Create POI object and add to vector
        }
    }
}

// compute the rewards generated by the provided agents configuration
std::vector<int> Environment::getRewards(std::vector<std::pair<double, double>> agentPositions) {
    std::vector<int> rewardVector;

    // Determine the number of unique class IDs
    std::unordered_set<int> uniqueClassIds;
    for(const auto& poi : pois) {
        uniqueClassIds.insert(poi.classId);
    }
    int numberOfPOIClasses = uniqueClassIds.size();

    // As many elements in the reward vector as objectives (POI classes)
    for(int i = 0; i < numberOfPOIClasses; i++)
        rewardVector.push_back(0);
    
    // loop through each POI, and add its reward accordingly
    for (const auto& poi : pois) {
        int numberOfCloseAgents = 0;

        for (const auto agentPosition : agentPositions) {
            double posX = agentPosition.first;
            double posY = agentPosition.second;

            double dx = poi.x - posX;
            double dy = poi.y - posY;
            double distance = sqrt(dx * dx + dy * dy);

            if(distance <= poi.observationRadius)
                numberOfCloseAgents++;
        }

        rewardVector[poi.classId] = (numberOfCloseAgents >= poi.coupling) ? (rewardVector[poi.classId] + poi.reward) : (rewardVector[poi.classId]);
    }

    // Add in the penalties of each agent to each objective reward
    for(int i = 0; i < rewardVector.size(); i++)
        rewardVector[i] += agentPositions.size() * pois[0].penalty;

    return rewardVector;
}

void Environment::printInfo() const {
    std::cout << "POIs in the environment:" << std::endl;
    for (const auto& poi : pois) {
        std::cout << "ID: " << poi.id << ", Class: " << poi.classId 
        << ", Coordinates: (" << poi.x << ", " << poi.y << "), Observation Radius: " 
        << poi.observationRadius << std::endl;
    }
}

std::vector<POI> Environment::getPOIs() {
    return pois;
}

std::pair<int, int> Environment::getDimensions() {
    return std::make_pair(xLength, yLength);
}

void Environment::reset() {
    pois.clear();
    xLength = 0;
    yLength = 0;
}
